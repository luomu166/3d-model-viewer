<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D模型展示 - Three.js 高级版</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 18px;
            z-index: 1000;
        }
        #info {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 14px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
        }
        #controls {
            position: fixed;
            top: 20px;
            right: 20px;
            color: white;
            font-family: Arial, sans-serif;
            font-size: 14px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
        }
        .control-btn {
            display: block;
            margin: 5px 0;
            padding: 5px 10px;
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            border-radius: 3px;
            cursor: pointer;
        }
        .control-btn:hover {
            background: rgba(255,255,255,0.3);
        }
    </style>
</head>
<body>
    <div id="loading">正在加载模型...</div>
    <div id="info">
        <strong>Three.js 高级版</strong><br>
        鼠标左键：旋转 | 滚轮：缩放 | 右键：平移
    </div>
    <div id="controls">
        <button class="control-btn" onclick="viewer.resetCamera()">重置视角</button>
        <button class="control-btn" onclick="viewer.toggleWireframe()">线框模式</button>
        <button class="control-btn" onclick="viewer.toggleAnimation()">动画开关</button>
        <button class="control-btn" onclick="viewer.changeBackground()">切换背景</button>
    </div>
    <canvas id="canvas"></canvas>

    <!-- 引入Three.js库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

    <script>
        /**
         * Three.js 高级版3D模型展示器
         * 包含更多交互功能和视觉效果
         */
        class AdvancedModelViewer {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;
                this.model = null;
                this.loadingElement = document.getElementById('loading');
                this.wireframeMode = false;
                this.animationEnabled = true;
                this.backgroundIndex = 0;
                this.animationId = null;
                
                this.init();
            }

            /**
             * 初始化Three.js场景
             */
            init() {
                // 创建场景
                this.scene = new THREE.Scene();
                this.setupBackground();

                // 创建相机
                this.camera = new THREE.PerspectiveCamera(
                    75, 
                    window.innerWidth / window.innerHeight, 
                    0.1, 
                    1000
                );
                this.camera.position.set(0, 0, 5);

                // 创建渲染器
                this.renderer = new THREE.WebGLRenderer({ 
                    canvas: document.getElementById('canvas'),
                    antialias: true 
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                // 添加轨道控制器
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.screenSpacePanning = false;
                this.controls.minDistance = 1;
                this.controls.maxDistance = 50;

                // 添加光源
                this.setupLights();

                // 加载模型
                this.loadModel();

                // 开始渲染循环
                this.animate();

                // 监听窗口大小变化
                window.addEventListener('resize', () => this.onWindowResize());
            }

            /**
             * 设置背景
             */
            setupBackground() {
                const backgrounds = [
                    () => {
                        // 黑多白少渐变
                        const canvas = document.createElement('canvas');
                        canvas.width = 8192;
                        canvas.height = 4096;
                        const ctx = canvas.getContext('2d');
                        
                        const gradient = ctx.createRadialGradient(
                            canvas.width * 0.5, canvas.height * 0.5, 0,
                            canvas.width * 0.5, canvas.height * 0.5, canvas.width * 0.8
                        );
                        gradient.addColorStop(0, '#ffffff');
                        gradient.addColorStop(0.2, '#e0e0e0');
                        gradient.addColorStop(0.4, '#a0a0a0');
                        gradient.addColorStop(0.6, '#606060');
                        gradient.addColorStop(0.8, '#202020');
                        gradient.addColorStop(1, '#000000');
                        
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        const texture = new THREE.CanvasTexture(canvas);
                        this.scene.background = texture;
                    },
                    () => {
                        // 星空背景
                        const canvas = document.createElement('canvas');
                        canvas.width = 2048;
                        canvas.height = 1024;
                        const ctx = canvas.getContext('2d');
                        
                        ctx.fillStyle = '#000011';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        for (let i = 0; i < 2000; i++) {
                            const x = Math.random() * canvas.width;
                            const y = Math.random() * canvas.height;
                            const size = Math.random() * 2;
                            const opacity = Math.random() * 0.8 + 0.2;
                            
                            ctx.beginPath();
                            ctx.arc(x, y, size, 0, Math.PI * 2);
                            ctx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
                            ctx.fill();
                        }
                        
                        const texture = new THREE.CanvasTexture(canvas);
                        this.scene.background = texture;
                    },
                    () => {
                        // 纯色背景
                        this.scene.background = new THREE.Color(0x1a1a1a);
                    }
                ];
                
                backgrounds[this.backgroundIndex]();
            }

            /**
             * 设置场景光源
             */
            setupLights() {
                // 环境光
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                this.scene.add(ambientLight);

                // 方向光
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
                directionalLight.position.set(10, 10, 5);
                directionalLight.castShadow = true;
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                this.scene.add(directionalLight);

                // 补光
                const fillLight = new THREE.DirectionalLight(0xffffff, 0.6);
                fillLight.position.set(-10, -10, -5);
                this.scene.add(fillLight);
                
                // 顶部光源
                const topLight = new THREE.DirectionalLight(0xffffff, 0.8);
                topLight.position.set(0, 20, 0);
                topLight.castShadow = true;
                this.scene.add(topLight);
                
                // 半球光
                const hemisphereLight = new THREE.HemisphereLight(0x87ceeb, 0x8b4513, 0.6);
                this.scene.add(hemisphereLight);
            }

            /**
             * 加载GLB模型
             */
            loadModel() {
                const loader = new THREE.GLTFLoader();
                const modelPath = 'model.glb';
                
                loader.load(
                    modelPath,
                    (gltf) => {
                        this.model = gltf.scene;
                        
                        // 计算模型包围盒并调整位置
                        const box = new THREE.Box3().setFromObject(this.model);
                        const center = box.getCenter(new THREE.Vector3());
                        const size = box.getSize(new THREE.Vector3());
                        
                        // 将模型居中
                        this.model.position.sub(center);
                        
                        // 根据模型大小调整相机距离
                        const maxDim = Math.max(size.x, size.y, size.z);
                        const distance = maxDim * 2;
                        this.camera.position.set(distance, distance, distance);
                        this.controls.target.set(0, 0, 0);
                        this.controls.update();
                        
                        // 为模型添加阴影
                        this.model.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });
                        
                        this.scene.add(this.model);
                        
                        // 隐藏加载提示
                        this.loadingElement.style.display = 'none';
                        
                        console.log('Three.js高级版模型加载成功');
                    },
                    (progress) => {
                        const percent = Math.round((progress.loaded / progress.total) * 100);
                        this.loadingElement.textContent = `正在加载模型... ${percent}%`;
                    },
                    (error) => {
                        console.error('模型加载失败:', error);
                        this.loadingElement.textContent = '模型加载失败，请检查文件路径';
                        this.loadingElement.style.color = '#ff4444';
                    }
                );
            }

            /**
             * 渲染循环
             */
            animate() {
                this.animationId = requestAnimationFrame(() => this.animate());
                
                // 更新控制器
                this.controls.update();
                
                // 模型动画
                if (this.animationEnabled && this.model) {
                    this.model.rotation.y += 0.005;
                }
                
                // 渲染场景
                this.renderer.render(this.scene, this.camera);
            }

            /**
             * 窗口大小变化处理
             */
            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            /**
             * 重置相机
             */
            resetCamera() {
                if (this.model) {
                    const box = new THREE.Box3().setFromObject(this.model);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const distance = maxDim * 2;
                    
                    this.camera.position.set(distance, distance, distance);
                    this.controls.target.copy(center);
                    this.controls.update();
                }
            }

            /**
             * 切换线框模式
             */
            toggleWireframe() {
                this.wireframeMode = !this.wireframeMode;
                if (this.model) {
                    this.model.traverse((child) => {
                        if (child.isMesh && child.material) {
                            child.material.wireframe = this.wireframeMode;
                        }
                    });
                }
            }

            /**
             * 切换动画
             */
            toggleAnimation() {
                this.animationEnabled = !this.animationEnabled;
            }

            /**
             * 切换背景
             */
            changeBackground() {
                this.backgroundIndex = (this.backgroundIndex + 1) % 3;
                this.setupBackground();
            }
        }

        // 全局变量，供按钮使用
        let viewer;

        // 页面加载完成后初始化
        window.addEventListener('load', () => {
            viewer = new AdvancedModelViewer();
        });
    </script>
</body>
</html> 